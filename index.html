<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Racing Adventures</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <style>
      body {
        color: #61443e;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;

        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }
      #speedometer {
        color: #ffffff;
        background-color: #990000;
        position: absolute;
        bottom: 0px;
        padding: 5px;
      }
      a {
        color: #a06851;
      }
    </style>
  </head>
  <body>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>
    <div id="speedometer">0.0 km/h</div>

    <script src="ammo.js"></script>

    <script src="three.js"></script>

    <script>
      Ammo().then(function (Ammo) {
        // Graphics variables
        let camera, scene, renderer
        let clock = new THREE.Clock()
        let materialDynamic, materialRoad, materialRoadCorner, materialInteractive

        // Physics variables
        let physicsWorld
        let syncList = []
        let time = 0

        // Keybord actions
        let actions = {}
        let keysActions = {
          KeyW: 'acceleration',
          KeyS: 'braking',
          KeyA: 'left',
          KeyD: 'right',
        }

        // - Functions -

        function initGraphics() {
          scene = new THREE.Scene()

          camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.2,
            2000
          )

          renderer = new THREE.WebGLRenderer({antialias: true})
          renderer.setClearColor(0xbfd1e5)
          renderer.setPixelRatio(window.devicePixelRatio)
          renderer.setSize(window.innerWidth, window.innerHeight)

          let ambientLight = new THREE.AmbientLight(0x404040)
          scene.add(ambientLight)

          let dirLight = new THREE.DirectionalLight(0xffffff, 1)
          dirLight.position.set(10, 10, 5)
          scene.add(dirLight)

          const loader = new THREE.TextureLoader()

          materialDynamic = new THREE.MeshPhongMaterial({color: 0xfca400})
          const materialRoadUntextured = new THREE.MeshPhongMaterial({color: 0x999999})
          materialRoad = [
            materialRoadUntextured,
            materialRoadUntextured,
            new THREE.MeshPhongMaterial({
              color: 0x999999,
              map: loader.load('textures/road.png'),
            }),
            materialRoadUntextured,
            materialRoadUntextured,
            materialRoadUntextured,
          ]
          materialRoadCorner = [
            materialRoadUntextured,
            materialRoadUntextured,
            new THREE.MeshPhongMaterial({
              color: 0x999999,
              map: loader.load('textures/road-corner.png'),
            }),
            materialRoadUntextured,
            materialRoadUntextured,
            materialRoadUntextured,
          ]
          materialInteractive = new THREE.MeshPhongMaterial({color: 0x990000})

          document.getElementById('container').replaceChildren(renderer.domElement)

          window.addEventListener('resize', onWindowResize, false)
          window.addEventListener('keydown', keydown)
          window.addEventListener('keyup', keyup)
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()

          renderer.setSize(window.innerWidth, window.innerHeight)
        }

        function initPhysics() {
          let collisionConfig = new Ammo.btDefaultCollisionConfiguration()
          physicsWorld = new Ammo.btDiscreteDynamicsWorld(
            new Ammo.btCollisionDispatcher(collisionConfig),
            new Ammo.btDbvtBroadphase(),
            new Ammo.btSequentialImpulseConstraintSolver(),
            collisionConfig
          )
          physicsWorld.setGravity(new Ammo.btVector3(0, -9.82, 0))
        }

        function tick() {
          requestAnimationFrame(tick)
          let dt = clock.getDelta()
          for (let i = 0; i < syncList.length; i++) syncList[i](dt)
          physicsWorld.stepSimulation(dt, 10)
          renderer.render(scene, camera)
          time += dt
        }

        function keyup(e) {
          if (keysActions[e.code]) {
            actions[keysActions[e.code]] = false
            e.preventDefault()
            e.stopPropagation()
            return false
          }
        }
        function keydown(e) {
          if (keysActions[e.code]) {
            actions[keysActions[e.code]] = true
            e.preventDefault()
            e.stopPropagation()
            return false
          }
        }

        function createCorner(
          pos,
          w,
          l,
          h,
          mass = 0,
          friction = 1,
          rot = new THREE.Quaternion(0, 0, 0, 1)
        ) {
          let geometry = new Ammo.btBoxShape(
            new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5)
          )

          const geo = new THREE.BufferGeometry()
          // create a simple square shape. We duplicate the top left and bottom right
          // vertices because each vertex needs to appear once per triangle.
          const vertices = new Float32Array([
            -w / 2,
            l / 2,
            h / 2,
            w / 2,
            l / 2,
            h / 2,
            -w / 2,
            l / 2,
            -h / 2,
          ])
          const uv = new Float32Array([0, 0, 1, 0, 0, 1])
          const normals = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0])

          geo.setIndex([0, 1, 2])
          geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3))
          geo.setAttribute('uv', new THREE.BufferAttribute(uv, 2))
          geo.setAttribute('normal', new THREE.BufferAttribute(normals, 3))
          geo.addGroup(0, 3, 2)

          let mesh = new THREE.Mesh(geo, materialRoadCorner)
          mesh.position.copy(pos)
          mesh.quaternion.copy(rot)
          scene.add(mesh)

          let transform = new Ammo.btTransform()
          transform.setIdentity()
          transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))
          transform.setRotation(new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w))
          let motionState = new Ammo.btDefaultMotionState(transform)

          let localInertia = new Ammo.btVector3(0, 0, 0)
          geometry.calculateLocalInertia(mass, localInertia)

          let rbInfo = new Ammo.btRigidBodyConstructionInfo(
            mass,
            motionState,
            geometry,
            localInertia
          )
          let body = new Ammo.btRigidBody(rbInfo)

          body.setFriction(friction)

          physicsWorld.addRigidBody(body)
        }

        function createBox(
          pos,
          w,
          l,
          h,
          mass = 0,
          friction = 1,
          rot = new THREE.Quaternion(0, 0, 0, 1)
        ) {
          let material = mass > 0 ? materialDynamic : materialRoad
          let shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1)

          let geometry = new Ammo.btBoxShape(
            new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5)
          )

          let mesh = new THREE.Mesh(shape, material)

          mesh.position.copy(pos)
          mesh.quaternion.copy(rot)
          scene.add(mesh)

          let transform = new Ammo.btTransform()
          transform.setIdentity()
          transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))
          transform.setRotation(new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w))
          let motionState = new Ammo.btDefaultMotionState(transform)

          let localInertia = new Ammo.btVector3(0, 0, 0)
          geometry.calculateLocalInertia(mass, localInertia)

          let rbInfo = new Ammo.btRigidBodyConstructionInfo(
            mass,
            motionState,
            geometry,
            localInertia
          )
          let body = new Ammo.btRigidBody(rbInfo)

          body.setFriction(friction)

          physicsWorld.addRigidBody(body)

          if (mass > 0) {
            // Sync physics and graphics
            const sync = () => {
              let ms = body.getMotionState()
              if (ms) {
                let transform = new Ammo.btTransform()
                ms.getWorldTransform(transform)
                let pos = transform.getOrigin()
                let rot = transform.getRotation()
                mesh.position.set(pos.x(), pos.y(), pos.z())
                mesh.quaternion.set(rot.x(), rot.y(), rot.z(), rot.w())
              }
            }

            syncList.push(sync)
          }
        }

        function createWheelMesh(radius, width) {
          let t = new THREE.CylinderGeometry(radius, radius, width, 8, 1)
          t.rotateZ(Math.PI / 2)
          let mesh = new THREE.Mesh(t, materialInteractive)
          scene.add(mesh)
          return mesh
        }

        function createChassisMesh(w, l, h) {
          let shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1)
          let mesh = new THREE.Mesh(shape, materialInteractive)
          scene.add(mesh)
          return mesh
        }

        function createVehicle(pos) {
          // Vehicle contants

          let chassisWidth = 1.8
          let chassisHeight = 0.6
          let chassisLength = 4
          let massVehicle = 800

          let wheelRadius = 0.5
          let wheelWidth = 0.2

          let axleFrontPos = 1.7
          let axleBackPos = -1
          let axleHalfLength = 1
          let axleHeight = 0.3

          let friction = 1000
          let suspensionStiffness = 20.0
          let suspensionDamping = 2.3
          let suspensionCompression = 4.4
          let suspensionRestLength = 0.6
          let rollInfluence = 0.1

          let steeringIncrement = 0.04
          let steeringClamp = 0.5
          let maxEngineForce = 2000
          let maxBreakingForce = 100

          // Chassis
          let geometry = new Ammo.btBoxShape(
            new Ammo.btVector3(
              chassisWidth * 0.5,
              chassisHeight * 0.5,
              chassisLength * 0.5
            )
          )
          let transform = new Ammo.btTransform()
          transform.setIdentity()
          transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))
          let motionState = new Ammo.btDefaultMotionState(transform)
          let localInertia = new Ammo.btVector3(0, 0, 0)
          geometry.calculateLocalInertia(massVehicle, localInertia)
          let body = new Ammo.btRigidBody(
            new Ammo.btRigidBodyConstructionInfo(
              massVehicle,
              motionState,
              geometry,
              localInertia
            )
          )
          physicsWorld.addRigidBody(body)
          let chassisMesh = createChassisMesh(
            chassisWidth,
            chassisHeight,
            chassisLength
          )

          // Raycast Vehicle
          let engineForce = 0
          let vehicleSteering = 0
          let breakingForce = 0
          let tuning = new Ammo.btVehicleTuning()
          let rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld)
          let vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster)
          vehicle.setCoordinateSystem(0, 1, 2)
          physicsWorld.addAction(vehicle)

          // Wheels
          let FRONT_LEFT = 0
          let FRONT_RIGHT = 1
          let BACK_LEFT = 2
          let BACK_RIGHT = 3
          let wheelMeshes = []
          let wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0)
          let wheelAxleCS = new Ammo.btVector3(-1, 0, 0)

          function addWheel(isFront, pos, radius, width, index) {
            let wheelInfo = vehicle.addWheel(
              pos,
              wheelDirectionCS0,
              wheelAxleCS,
              suspensionRestLength,
              radius,
              tuning,
              isFront
            )

            wheelInfo.set_m_suspensionStiffness(suspensionStiffness)
            wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping)
            wheelInfo.set_m_wheelsDampingCompression(suspensionCompression)
            wheelInfo.set_m_frictionSlip(friction)
            wheelInfo.set_m_rollInfluence(rollInfluence)

            wheelMeshes[index] = createWheelMesh(radius, width)
          }

          addWheel(
            true,
            new Ammo.btVector3(axleHalfLength, axleHeight, axleFrontPos),
            wheelRadius,
            wheelWidth,
            FRONT_LEFT
          )
          addWheel(
            true,
            new Ammo.btVector3(-axleHalfLength, axleHeight, axleFrontPos),
            wheelRadius,
            wheelWidth,
            FRONT_RIGHT
          )
          addWheel(
            false,
            new Ammo.btVector3(-axleHalfLength, axleHeight, axleBackPos),
            wheelRadius,
            wheelWidth,
            BACK_LEFT
          )
          addWheel(
            false,
            new Ammo.btVector3(axleHalfLength, axleHeight, axleBackPos),
            wheelRadius,
            wheelWidth,
            BACK_RIGHT
          )

          // Sync keybord actions and physics and graphics
          function sync() {
            let speed = vehicle.getCurrentSpeedKmHour()

            breakingForce = 0
            engineForce = 0

            if (actions.acceleration) {
              if (speed < -1) breakingForce = maxBreakingForce
              else engineForce = maxEngineForce
            }
            if (actions.braking) {
              if (speed > 1) breakingForce = maxBreakingForce
              else engineForce = -maxEngineForce / 2
            }
            if (actions.left) {
              if (vehicleSteering < steeringClamp) vehicleSteering += steeringIncrement
            } else {
              if (actions.right) {
                if (vehicleSteering > -steeringClamp)
                  vehicleSteering -= steeringIncrement
              } else {
                if (vehicleSteering < -steeringIncrement)
                  vehicleSteering += steeringIncrement
                else {
                  if (vehicleSteering > steeringIncrement)
                    vehicleSteering -= steeringIncrement
                  else {
                    vehicleSteering = 0
                  }
                }
              }
            }

            vehicle.applyEngineForce(engineForce, BACK_LEFT)
            vehicle.applyEngineForce(engineForce, BACK_RIGHT)

            vehicle.setBrake(breakingForce / 2, FRONT_LEFT)
            vehicle.setBrake(breakingForce / 2, FRONT_RIGHT)
            vehicle.setBrake(breakingForce, BACK_LEFT)
            vehicle.setBrake(breakingForce, BACK_RIGHT)

            vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT)
            vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT)

            for (let i = 0; i < vehicle.getNumWheels(); i++) {
              vehicle.updateWheelTransform(i, true)
              let wheel_transform = vehicle.getWheelTransformWS(i)
              let pos = wheel_transform.getOrigin()
              let rot = wheel_transform.getRotation()
              wheelMeshes[i].position.set(pos.x(), pos.y(), pos.z())
              wheelMeshes[i].quaternion.set(rot.x(), rot.y(), rot.z(), rot.w())
            }

            let chassis_transform = vehicle.getChassisWorldTransform()
            let pos = chassis_transform.getOrigin()
            let rot = chassis_transform.getRotation()
            chassisMesh.position.set(pos.x(), pos.y(), pos.z())
            chassisMesh.quaternion.set(rot.x(), rot.y(), rot.z(), rot.w())

            let camera_offset = new THREE.Vector3(0, 2, -6)
            camera_offset.applyQuaternion(chassisMesh.quaternion)

            camera.position.copy(camera_offset.add(chassisMesh.position))
            camera.lookAt(chassisMesh.position)

            document.getElementById('speedometer').innerHTML = `${speed.toFixed(
              1
            )} km/h ${pos.x().toFixed(2)} ${pos.y().toFixed(2)} ${pos.z().toFixed(2)}`
          }

          syncList.push(sync)
        }

        function createObjects() {
          const block_size = 16
          let block_height = block_size / 8

          let hash = location.hash.slice(1)

          const chars =
            "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_?/:@.~!$&'()*+,="

          for (let i = 0; i < hash.length; i += 4) {
            let block_type = Math.floor(chars.indexOf(hash[i]) / 4)
            let block_dir = chars.indexOf(hash[i]) % 4
            let rot = new THREE.Quaternion(0, 0, 0, 1)
            rot.setFromAxisAngle(new THREE.Vector3(0, 1, 0), (-block_dir * Math.PI) / 2)
            if (block_type == 0) {
              createBox(
                new THREE.Vector3(
                  block_size * chars.indexOf(hash[i + 1]),
                  -block_height + block_height * chars.indexOf(hash[i + 2]),
                  block_size * chars.indexOf(hash[i + 3])
                ),
                block_size,
                block_height,
                block_size,
                0,
                0,
                rot
              )
            } else if (block_type == 1) {
              let ramp = new THREE.Quaternion(0, 0, 0, 1)
              ramp.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -0.12435)
              rot.multiply(ramp)
              createBox(
                new THREE.Vector3(
                  block_size * chars.indexOf(hash[i + 1]),
                  -block_height / 2 + block_height * chars.indexOf(hash[i + 2]),
                  block_size * chars.indexOf(hash[i + 3])
                ),
                block_size,
                block_height,
                block_size * 1.023,
                0,
                1,
                rot
              )
            } else if (block_type == 2) {
              createCorner(
                new THREE.Vector3(
                  block_size * chars.indexOf(hash[i + 1]),
                  -block_height + block_height * chars.indexOf(hash[i + 2]),
                  block_size * chars.indexOf(hash[i + 3])
                ),
                block_size,
                block_height,
                block_size * 1.023,
                0,
                1,
                rot
              )
            }
          }

          createVehicle(new THREE.Vector3(0, 2, block_size))
        }

        // - Init -
        initGraphics()
        initPhysics()
        createObjects()
        tick()
      })
    </script>
  </body>
</html>
