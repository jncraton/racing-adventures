<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Racing Adventures</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        color: #61443e;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;

        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }
      #speedometer {
        color: #ffffff;
        background-color: #990000;
        position: absolute;
        bottom: 0px;
        padding: 5px;
      }
      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
      }

      a {
        color: #a06851;
      }
    </style>
  </head>
  <body>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>
    <div id="speedometer">0.0 km/h</div>

    <script src="ammo.js"></script>

    <script src="three.js"></script>
    <script src="Detector.js"></script>

    <script>
      Ammo().then(function (Ammo) {
        // Detects webgl
        if (!Detector.webgl) {
          Detector.addGetWebGLMessage()
          document.getElementById('container').innerHTML = ''
        }

        // - Global variables -
        let DISABLE_DEACTIVATION = 4
        let TRANSFORM_AUX = new Ammo.btTransform()
        let ZERO_QUATERNION = new THREE.Quaternion(0, 0, 0, 1)

        // Graphics variables
        let container, speedometer
        let camera, scene, renderer
        let terrainMesh, texture
        let clock = new THREE.Clock()
        let materialDynamic, materialStatic, materialInteractive

        // Physics variables
        let collisionConfiguration
        let dispatcher
        let broadphase
        let solver
        let physicsWorld

        let syncList = []
        let time = 0
        let objectTimePeriod = 3
        let timeNextSpawn = time + objectTimePeriod
        let maxNumObjects = 30

        // Keybord actions
        let actions = {}
        let keysActions = {
          KeyW: 'acceleration',
          KeyS: 'braking',
          KeyA: 'left',
          KeyD: 'right',
        }

        // - Functions -

        function initGraphics() {
          container = document.getElementById('container')
          speedometer = document.getElementById('speedometer')

          scene = new THREE.Scene()

          camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.2,
            2000
          )
          camera.position.x = -4.84
          camera.position.y = 4.39
          camera.position.z = -35.11
          camera.lookAt(new THREE.Vector3(0.33, -0.4, 0.85))

          renderer = new THREE.WebGLRenderer({ antialias: true })
          renderer.setClearColor(0xbfd1e5)
          renderer.setPixelRatio(window.devicePixelRatio)
          renderer.setSize(window.innerWidth, window.innerHeight)

          let ambientLight = new THREE.AmbientLight(0x404040)
          scene.add(ambientLight)

          let dirLight = new THREE.DirectionalLight(0xffffff, 1)
          dirLight.position.set(10, 10, 5)
          scene.add(dirLight)

          materialDynamic = new THREE.MeshPhongMaterial({ color: 0xfca400 })
          materialStatic = new THREE.MeshPhongMaterial({ color: 0x999999 })
          materialInteractive = new THREE.MeshPhongMaterial({ color: 0x990000 })

          container.innerHTML = ''

          container.appendChild(renderer.domElement)

          window.addEventListener('resize', onWindowResize, false)
          window.addEventListener('keydown', keydown)
          window.addEventListener('keyup', keyup)
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()

          renderer.setSize(window.innerWidth, window.innerHeight)
        }

        function initPhysics() {
          // Physics configuration
          collisionConfiguration = new Ammo.btDefaultCollisionConfiguration()
          dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration)
          broadphase = new Ammo.btDbvtBroadphase()
          solver = new Ammo.btSequentialImpulseConstraintSolver()
          physicsWorld = new Ammo.btDiscreteDynamicsWorld(
            dispatcher,
            broadphase,
            solver,
            collisionConfiguration
          )
          physicsWorld.setGravity(new Ammo.btVector3(0, -9.82, 0))
        }

        function tick() {
          requestAnimationFrame(tick)
          let dt = clock.getDelta()
          for (let i = 0; i < syncList.length; i++) syncList[i](dt)
          physicsWorld.stepSimulation(dt, 10)
          renderer.render(scene, camera)
          time += dt
        }

        function keyup(e) {
          if (keysActions[e.code]) {
            actions[keysActions[e.code]] = false
            e.preventDefault()
            e.stopPropagation()
            return false
          }
        }
        function keydown(e) {
          if (keysActions[e.code]) {
            actions[keysActions[e.code]] = true
            e.preventDefault()
            e.stopPropagation()
            return false
          }
        }

        function createBox(pos, quat, w, l, h, mass, friction) {
          let material = mass > 0 ? materialDynamic : materialStatic
          let shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1)
          let geometry = new Ammo.btBoxShape(
            new Ammo.btVector3(w * 0.5, l * 0.5, h * 0.5)
          )

          if (!mass) mass = 0
          if (!friction) friction = 1

          let mesh = new THREE.Mesh(shape, material)
          mesh.position.copy(pos)
          mesh.quaternion.copy(quat)
          scene.add(mesh)

          let transform = new Ammo.btTransform()
          transform.setIdentity()
          transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))
          transform.setRotation(
            new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
          )
          let motionState = new Ammo.btDefaultMotionState(transform)

          let localInertia = new Ammo.btVector3(0, 0, 0)
          geometry.calculateLocalInertia(mass, localInertia)

          let rbInfo = new Ammo.btRigidBodyConstructionInfo(
            mass,
            motionState,
            geometry,
            localInertia
          )
          let body = new Ammo.btRigidBody(rbInfo)

          body.setFriction(friction)

          physicsWorld.addRigidBody(body)

          if (mass > 0) {
            body.setActivationState(DISABLE_DEACTIVATION)
            // Sync physics and graphics
            function sync(dt) {
              let ms = body.getMotionState()
              if (ms) {
                ms.getWorldTransform(TRANSFORM_AUX)
                let p = TRANSFORM_AUX.getOrigin()
                let q = TRANSFORM_AUX.getRotation()
                mesh.position.set(p.x(), p.y(), p.z())
                mesh.quaternion.set(q.x(), q.y(), q.z(), q.w())
              }
            }

            syncList.push(sync)
          }
        }

        function createWheelMesh(radius, width) {
          let t = new THREE.CylinderGeometry(radius, radius, width, 24, 1)
          t.rotateZ(Math.PI / 2)
          let mesh = new THREE.Mesh(t, materialInteractive)
          mesh.add(
            new THREE.Mesh(
              new THREE.BoxGeometry(
                width * 1.5,
                radius * 1.75,
                radius * 0.25,
                1,
                1,
                1
              ),
              materialInteractive
            )
          )
          scene.add(mesh)
          return mesh
        }

        function createChassisMesh(w, l, h) {
          let shape = new THREE.BoxGeometry(w, l, h, 1, 1, 1)
          let mesh = new THREE.Mesh(shape, materialInteractive)
          scene.add(mesh)
          return mesh
        }

        function createVehicle(pos, quat) {
          // Vehicle contants

          let chassisWidth = 1.8
          let chassisHeight = 0.6
          let chassisLength = 4
          let massVehicle = 800

          let wheelAxisPositionBack = -1
          let wheelRadiusBack = 0.4
          let wheelWidthBack = 0.3
          let wheelHalfTrackBack = 1
          let wheelAxisHeightBack = 0.3

          let wheelAxisFrontPosition = 1.7
          let wheelHalfTrackFront = 1
          let wheelAxisHeightFront = 0.3
          let wheelRadiusFront = 0.35
          let wheelWidthFront = 0.2

          let friction = 1000
          let suspensionStiffness = 20.0
          let suspensionDamping = 2.3
          let suspensionCompression = 4.4
          let suspensionRestLength = 0.6
          let rollInfluence = 0.2

          let steeringIncrement = 0.04
          let steeringClamp = 0.5
          let maxEngineForce = 2000
          let maxBreakingForce = 100

          // Chassis
          let geometry = new Ammo.btBoxShape(
            new Ammo.btVector3(
              chassisWidth * 0.5,
              chassisHeight * 0.5,
              chassisLength * 0.5
            )
          )
          let transform = new Ammo.btTransform()
          transform.setIdentity()
          transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))
          transform.setRotation(
            new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
          )
          let motionState = new Ammo.btDefaultMotionState(transform)
          let localInertia = new Ammo.btVector3(0, 0, 0)
          geometry.calculateLocalInertia(massVehicle, localInertia)
          let body = new Ammo.btRigidBody(
            new Ammo.btRigidBodyConstructionInfo(
              massVehicle,
              motionState,
              geometry,
              localInertia
            )
          )
          body.setActivationState(DISABLE_DEACTIVATION)
          physicsWorld.addRigidBody(body)
          let chassisMesh = createChassisMesh(
            chassisWidth,
            chassisHeight,
            chassisLength
          )

          // Raycast Vehicle
          let engineForce = 0
          let vehicleSteering = 0
          let breakingForce = 0
          let tuning = new Ammo.btVehicleTuning()
          let rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld)
          let vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster)
          vehicle.setCoordinateSystem(0, 1, 2)
          physicsWorld.addAction(vehicle)

          // Wheels
          let FRONT_LEFT = 0
          let FRONT_RIGHT = 1
          let BACK_LEFT = 2
          let BACK_RIGHT = 3
          let wheelMeshes = []
          let wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0)
          let wheelAxleCS = new Ammo.btVector3(-1, 0, 0)

          function addWheel(isFront, pos, radius, width, index) {
            let wheelInfo = vehicle.addWheel(
              pos,
              wheelDirectionCS0,
              wheelAxleCS,
              suspensionRestLength,
              radius,
              tuning,
              isFront
            )

            wheelInfo.set_m_suspensionStiffness(suspensionStiffness)
            wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping)
            wheelInfo.set_m_wheelsDampingCompression(suspensionCompression)
            wheelInfo.set_m_frictionSlip(friction)
            wheelInfo.set_m_rollInfluence(rollInfluence)

            wheelMeshes[index] = createWheelMesh(radius, width)
          }

          addWheel(
            true,
            new Ammo.btVector3(
              wheelHalfTrackFront,
              wheelAxisHeightFront,
              wheelAxisFrontPosition
            ),
            wheelRadiusFront,
            wheelWidthFront,
            FRONT_LEFT
          )
          addWheel(
            true,
            new Ammo.btVector3(
              -wheelHalfTrackFront,
              wheelAxisHeightFront,
              wheelAxisFrontPosition
            ),
            wheelRadiusFront,
            wheelWidthFront,
            FRONT_RIGHT
          )
          addWheel(
            false,
            new Ammo.btVector3(
              -wheelHalfTrackBack,
              wheelAxisHeightBack,
              wheelAxisPositionBack
            ),
            wheelRadiusBack,
            wheelWidthBack,
            BACK_LEFT
          )
          addWheel(
            false,
            new Ammo.btVector3(
              wheelHalfTrackBack,
              wheelAxisHeightBack,
              wheelAxisPositionBack
            ),
            wheelRadiusBack,
            wheelWidthBack,
            BACK_RIGHT
          )

          // Sync keybord actions and physics and graphics
          function sync(dt) {
            let speed = vehicle.getCurrentSpeedKmHour()

            breakingForce = 0
            engineForce = 0

            if (actions.acceleration) {
              if (speed < -1) breakingForce = maxBreakingForce
              else engineForce = maxEngineForce
            }
            if (actions.braking) {
              if (speed > 1) breakingForce = maxBreakingForce
              else engineForce = -maxEngineForce / 2
            }
            if (actions.left) {
              if (vehicleSteering < steeringClamp)
                vehicleSteering += steeringIncrement
            } else {
              if (actions.right) {
                if (vehicleSteering > -steeringClamp)
                  vehicleSteering -= steeringIncrement
              } else {
                if (vehicleSteering < -steeringIncrement)
                  vehicleSteering += steeringIncrement
                else {
                  if (vehicleSteering > steeringIncrement)
                    vehicleSteering -= steeringIncrement
                  else {
                    vehicleSteering = 0
                  }
                }
              }
            }

            vehicle.applyEngineForce(engineForce, BACK_LEFT)
            vehicle.applyEngineForce(engineForce, BACK_RIGHT)

            vehicle.setBrake(breakingForce / 2, FRONT_LEFT)
            vehicle.setBrake(breakingForce / 2, FRONT_RIGHT)
            vehicle.setBrake(breakingForce, BACK_LEFT)
            vehicle.setBrake(breakingForce, BACK_RIGHT)

            vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT)
            vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT)

            let tm, p, q, i
            let n = vehicle.getNumWheels()
            for (i = 0; i < n; i++) {
              vehicle.updateWheelTransform(i, true)
              tm = vehicle.getWheelTransformWS(i)
              p = tm.getOrigin()
              q = tm.getRotation()
              wheelMeshes[i].position.set(p.x(), p.y(), p.z())
              wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w())
            }

            tm = vehicle.getChassisWorldTransform()
            p = tm.getOrigin()
            q = tm.getRotation()
            chassisMesh.position.set(p.x(), p.y(), p.z())
            chassisMesh.quaternion.set(q.x(), q.y(), q.z(), q.w())

            let camera_offset = new THREE.Vector3(0, 2, -6)
            camera_offset.applyQuaternion(chassisMesh.quaternion)
            camera_position = camera_offset.add(chassisMesh.position)

            camera.position.set(
              camera_position.x,
              camera_position.y,
              camera_position.z
            )
            camera.lookAt(chassisMesh.position)

            speedometer.innerHTML = `${speed.toFixed(1)} km/h ${p.x().toFixed(2)} ${p.y().toFixed(2)} ${p.z().toFixed(2)}`
          }

          syncList.push(sync)
        }

        function createObjects() {
          createBox(
            new THREE.Vector3(0, -0.5, 0),
            ZERO_QUATERNION,
            16,
            1,
            75,
            0,
            2
          )

          createBox(
            new THREE.Vector3(75, -0.5, 0),
            ZERO_QUATERNION,
            16,
            1,
            75,
            0,
            2
          )

          createBox(
            new THREE.Vector3(75 / 2, -0.5, 75 / 2),
            ZERO_QUATERNION,
            75,
            1,
            16,
            0,
            2
          )

          createBox(
            new THREE.Vector3(75 / 2, -0.5, -75 / 2),
            ZERO_QUATERNION,
            75,
            1,
            16,
            0,
            2
          )

          let quaternion = new THREE.Quaternion(0, 0, 0, 1)
          quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 18)
          createBox(new THREE.Vector3(0, -1.5, 0), quaternion, 8, 4, 10, 0)

          let size = 3
          let nw = 2
          let nh = 2
          for (let j = 0; j < nw; j++)
            for (let i = 0; i < nh; i++)
              createBox(
                new THREE.Vector3(
                  size * j - (size * (nw - 1)) / 2,
                  size * i,
                  10
                ),
                ZERO_QUATERNION,
                size,
                size,
                size,
                10
              )

          createVehicle(new THREE.Vector3(0, 4, 0), ZERO_QUATERNION)
        }

        // - Init -
        initGraphics()
        initPhysics()
        createObjects()
        tick()
      })
    </script>
  </body>
</html>
